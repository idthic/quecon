#!/usr/bin/env bash

idtsub_prefix=~/.opt/idt
idtsub_data_path=$idtsub_prefix/share/idtsub
idtsub_tmpdir_base=/dev/shm/$UID.$USER

function is-function { declare -f "$1" &>/dev/null; }

## @fn make-jobdir
##   @var[out] jobdir
function make-jobdir {
  jobdir=
  local jobdir_base=$idtsub_data_path/jobs
  [[ -d $jobdir_base ]] || mkdir -p "$jobdir_base"
  local date=$(date +%Y%m%d-%H%M%S)
  local index=0
  for ((index=0;index<100;index++)); do
    printf -v jobdir %s/%s-%02d "$jobdir_base" "$date" "$index"
    mkdir "$jobdir" 2>/dev/null && return 0
  done
  jobdir=
  echo "idtsub: failed to create job directory" >&2
  return 1
}

## @fn read-args args...
##   @var[out] flags
##   @var[out] command
##   @var[out] range
##   @var[out] job_name
function read-args {
  flags= command= range= job_name=
  while (($#)); do
    local arg=$1; shift
    if [[ $arg == -* ]]; then
      case $arg in
      (-c) flags+=c ;;
      (-t) flags+=t ;;
      (-J) job_name=$1; shift ;;
      (-r) range=$1; shift ;;
      (*)
        echo "idtsub: unrecognized option '$arg'" >&2
        flags+=E ;;
      esac
    elif [[ ! $command ]]; then
      command=$arg
    else
      echo "idtsub: command is already specified." >&2
      flags+=E
    fi
  done
  if [[ ! $command ]]; then
    echo "idtsub: command is not specified." >&2
    flags+=E
  fi
  [[ $flags != *E* ]]
}

function cmd:submit {
  local flags command range job_name
  read-args "$@" || return 2

  # Loop settings
  local range_{rep=,beg=0,end=1,cpu=1}
  if [[ $range ]]; then
    local rex='([^=]+=)?([0-9]+:)?([0-9]+)(/[0-9]+)?'
    if ! [[ $range =~ $rex ]]; then
      echo "idtsub: invalid range spec '-r $range'." >&2
      return 2
    fi
    range_rep=${BASH_REMATCH[1]%=}
    range_beg=${BASH_REMATCH[2]%:}
    range_end=${BASH_REMATCH[3]}
    range_cpu=${BASH_REMATCH[4]#/}
    [[ $range_beg ]] || range_beg=0
    [[ $range_cpu ]] || range_cpu=1
  fi

  # Job name
  [[ $job_name ]] || job_name=$command
  
  local batch_size=$(((range_end-range_beg+range_cpu-1)/range_cpu))
  local ijob=$range_beg
  for ((ijob=range_beg;ijob<range_end;ijob+=batch_size)); do
    local beg=$ijob end=$((ijob+batch_size))
    ((end>range_end)) && end=$range_end
    local count=$((end-beg))
    ((count>0)) || break

    local jobdir
    make-jobdir || return 1

    # Copy executable
    local command1=$command
    if [[ $flags == *c* ]]; then
      local cmd=${command%%[$IFS]*}
      local fcmd=$jobdir/cmd.sh
      if [[ -x $cmd ]] && cp -L "$cmd" "$fcmd"; then
        command1=$fcmd${command:${#cmd}}
      else
        "idtsub: failed to copy the file '$cmd'." >&2
        return 1
      fi
    fi

    local q=\' Q="'\''"
    local fjob=$jobdir/job.sh
    local flog=$jobdir/stat.log
    local fstat=$jobdir/stat.sh
    {
      echo '#!/usr/bin/env bash'
      echo "HOME='${HOME//$q/$Q}'"
      echo 'cd "$HOME"'
      echo ". $HOME/.bashrc"
      echo "cd '${PWD//$q/$Q}'"
      echo
      echo "IDTSUB_COMMAND='${command1//$q/$Q}'"
      echo "IDTSUB_REPLACE='${range_rep//$q/$Q}'"
      echo 'export IDTSUB_INDEX'
      echo "for IDTSUB_INDEX in {$beg..$((end-1))}; do"
      echo '  _idtsub_command=$IDTSUB_COMMAND'
      echo '  [[ $IDTSUB_REPLACE ]] &&'
      echo '    _idtsub_command=${IDTSUB_COMMAND//$IDTSUB_REPLACE/$IDTSUB_INDEX}'
      echo '  echo "[$(date +"%F %T %Z")] $_idtsub_command" >> "$flog"'
      echo "  echo \"stat=R(\$((IDTSUB_INDEX-$beg+1))/$count)\" >> \"$fstat\""
      echo '  eval "$_idtsub_command" || echo "((fail++))" >> "$fstat"'
      echo 'done'
    } > "$fjob"

    local fsub=$jobdir/sub.sh
    {
      echo '#!/usr/bin/env bash'
      echo 'echo "[$(date +"%F %T %Z")] IDTSUB run" >> "$flog"'
      echo 'echo "stat=R" >> "$fstat"'
      if [[ $flags == *t* ]]; then
        echo "export IDTSUB_TMPDIR=$idtsub_tmpdir_base/${jobdir##*/}"
        echo '[[ -d $IDTSUB_TMPDIR ]] ||'
        echo '  (umask 077; rm -rf "$IDTSUB_TMPDIR"; mkdir -p "$IDTSUB_TMPDIR")'
      fi
      echo "srun -n 1 $fjob"
      if [[ $flags == *t* ]]; then
        echo 'rm -rf "$IDTSUB_TMPDIR"'
      fi
      echo 'echo "[$(date +"%F %T %Z")] IDTSUB complete" >> "$flog"'
      echo 'echo "stat=C" >> "$fstat"'
      echo 'echo 1 >> "$jobdir/complete.mark"'
    } > "$fsub"

    chmod +x "$fjob" "$fsub"

    local job_range_suffix=
    local cmd_range_suffix=
    if [[ $range_rep || $beg != 0 && $end != 1 ]]; then
      job_range_suffix="[$beg:$end]"
      cmd_range_suffix=" (${range_rep:+$range_rep=}$beg:$end)"
    fi

    echo "[$(date +"%F %T %Z")] IDTSUB submit" >> "$flog"
    echo "command='${command//$q/$Q}$cmd_range_suffix'" >> "$fstat"
    echo "stat=P" >> "$fstat"
    echo "submit: $command$cmd_range_suffix"
    if ! (cd "$jobdir"; sbatch -N 1 -p amd_256 -J "$job_name$job_range_suffix" sub.sh); then
      echo "idtsub:${jobdir##*/}: failed to submit" >&2
      echo "[$(date +"%F %T %Z")] IDTSUB submit fail" >> "$flog"
      echo "stat=F" >> "$fstat"
      return 1
    fi
  done
}

function cmd:list {
  local flags=C

  local dir index=0
  for dir in "$idtsub_data_path"/jobs/*; do
    ((index++))
    local job_id=${dir##*/}
    local stat=- fail=0 command=-
    [[ $flags == *C* && -s $dir/complete.mark ]] && continue

    if [[ -s $dir/stat.sh ]]; then
      source "$dir/stat.sh"
    elif [[ -s $dir/complete.mark ]]; then
      stat=C
    fi

    ((fail)) && stat=F$fail
    stat=$stat'      '; stat=${stat::6}
    case $stat in
    (F*) stat=$'\e[1;91m'$stat$'\e[m' ;;
    (C*) stat=$'\e[94m'$stat$'\e[m' ;;
    (R*) stat=$'\e[1;92m'$stat$'\e[m' ;;
    (P*) stat=$'\e[32m'$stat$'\e[m' ;;
    esac

    local s_index
    printf -v s_index '%04d' "$index"
    echo "$s_index $job_id $stat $command"
  done
}

function idtsub/jobdir-eval {
  if [[ ! $1 || ${1//[0-9]} ]]; then
    echo "idtsub: invalid job_index '$1'." >&2
    return 1
  fi

  local index=$((10#$1)) command=$2
  local jobdir i=0
  for jobdir in "$idtsub_data_path"/jobs/*; do
    if ((i++==index)); then
      (cd "$jobdir"; eval -- "$command")
      return
    fi
  done
  echo "idtsub: job_index '$1' not found." >&2
  return 1
}

function cmd:out {
  if [[ $1 ]]; then
    idtsub/jobdir-eval "$1" '
      local option=
      [[ -s complete.mark ]] || option=-f
      tail $option slurm-*.out'
  else
    echo "usage: idtjob out JOB_INDEX" >&2
    return 2
  fi
}
function cmd:log {
  if [[ $1 ]]; then
    idtsub/jobdir-eval "$1" 'cat stat.log'
  else
    echo "usage: idtjob log JOB_INDEX" >&2
    return 2
  fi
}
function cmd:ls {
  if [[ $1 ]]; then
    idtsub/jobdir-eval "$1" 'ls -la'
  else
    echo "usage: idtjob ls JOB_INDEX" >&2
    return 2
  fi
}

if is-function "cmd:$1"; then
  "cmd:$@"
else
  echo "idtsub: unknown subcommand '$1'" >&2
  exit 2
fi
