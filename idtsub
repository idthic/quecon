#!/usr/bin/env bash

idtsub_prefix=~/.opt/idt
idtsub_data_path=$idtsub_prefix/share/idtsub
idtsub_tmpdir_base=/dev/shm/$UID.$USER

function is-function { declare -f "$1" &>/dev/null; }
function mkd { [[ -d $1 ]] || mkdir -p "$1"; }

function quote-words {
  local word out= q=\' Q="'\''" specialchars=$IFS$'|&;()[]{}<>\\`$?*~!^#'$q\"
  for word; do
    if [[ $word == *$'\n'* ]]; then
      printf -v word %q "$word"
    elif [[ $word == *["$specialchars"]* ]]; then
      word=$q${word//$q/$Q}$q
    fi
    out=${out:+$out' '}$word
  done
  ret=$out
}

## @fn cmd:submit/make-jobdir
##   @var[out] jobdir
function cmd:submit/make-jobdir {
  jobdir=
  local jobdir_base=$idtsub_data_path/jobs
  [[ -d $jobdir_base ]] || mkdir -p "$jobdir_base"
  local date=$(date +%Y%m%d-%H%M%S)
  local index=0
  for ((index=0;index<100;index++)); do
    printf -v jobdir %s/%s-%02d "$jobdir_base" "$date" "$index"
    mkdir "$jobdir" 2>/dev/null && return 0
  done
  jobdir=
  echo "idtsub: failed to create job directory" >&2
  return 1
}

## @fn cmd:submit/readargs args...
##   @var[out] flags
##     c   copy executable
##     t   create IDTSUB_TMPDIR
##     r   set range
##     E   error
##   @var[out] command
##   @var[out] range_{rep,beg,end,cpu}
##   @var[out] job_name
##   @var[out] bin_names
function cmd:submit/readargs {
  flags= command= job_name=
  bin_names=()
  local range
  while (($#)); do
    local arg=$1; shift
    if [[ $arg == -* ]]; then
      case $arg in
      (-c) flags+=c ;;
      (-C) bin_names+=("$1"); shift ;;
      (-t) flags+=t ;;
      (-J) job_name=$1; shift ;;
      (-r) flags+=r; range=$1; shift ;;
      (*)
        echo "idtsub: unrecognized option '$arg'" >&2
        flags+=E ;;
      esac
    elif [[ ! $command ]]; then
      command=$arg
    else
      echo "idtsub: command is already specified." >&2
      flags+=E
    fi
  done
  if [[ ! $command ]]; then
    echo "idtsub: command is not specified." >&2
    flags+=E
  fi

  # parse range
  range_rep=
  range_beg=0
  range_end=1
  range_cpu=1
  if [[ $range ]]; then
    local rex='([^=]+=)?([0-9]+:)?([0-9]+)(/[0-9]+)?'
    if ! [[ $range =~ $rex ]]; then
      echo "idtsub: invalid range spec '-r $range'." >&2
      flags+=E
    fi
    range_rep=${BASH_REMATCH[1]%=}
    range_beg=${BASH_REMATCH[2]%:}
    range_end=${BASH_REMATCH[3]}
    range_cpu=${BASH_REMATCH[4]#/}
    [[ $range_beg ]] || range_beg=0
    [[ $range_cpu ]] || range_cpu=1
  fi

  [[ $flags != *E* ]]
}

function cmd:submit {
  local q=\' Q="'\''"

  local flags command job_name bin_names
  local range_{rep=,beg=0,end=1,cpu=1}
  cmd:submit/readargs "$@" || return 2

  local submit_hash
  printf -v submit_hash '#%04X' "$RANDOM"
  local date=$(date +"%F %T %Z")
  local ret; quote-words idtsub submit "$@"
  echo "[$date] $submit_hash $ret" >> "$idtsub_data_path"/submit.log
  echo "[$date] $submit_hash PWD='${PWD//$q/$Q}'" >> "$idtsub_data_path"/submit.log

  # Job name
  [[ $job_name ]] || job_name=$command
  
  local batch_size=$(((range_end-range_beg+range_cpu-1)/range_cpu))
  local ijob=$range_beg icpu=0
  for ((ijob=range_beg;ijob<range_end;ijob+=batch_size)); do
    local beg=$ijob end=$((ijob+batch_size))
    ((end>range_end)) && end=$range_end
    local count=$((end-beg))
    ((count>0)) || break

    local jobdir
    cmd:submit/make-jobdir || return 1

    # Copy executable
    local command1=$command
    if [[ $flags == *c* ]]; then
      local cmd=${command%%[$IFS]*}
      local fcmd=$jobdir/cmd.sh
      if [[ -x $cmd ]] && cp -L "$cmd" "$fcmd"; then
        command1=$fcmd${command:${#cmd}}
      else
        "idtsub: failed to copy the file '$cmd'." >&2
        return 1
      fi
    fi
    local bin_name bin_path
    for bin_name in "${bin_names[@]}"; do
      if ! bin_path=$(type -p "$bin_name"); then
        "idtsub: failed to copy the binary '$bin_name'." >&2
        return 1
      fi
      mkd "$jobdir/bin"
      cp -L "$bin_path" "$jobdir/bin/${bin_name##*/}"
    done

    local fjob=$jobdir/job.sh
    local flog=$jobdir/stat.log
    local fstat=$jobdir/stat.sh
    {
      echo '#!/usr/bin/env bash'
      echo "IDTSUB_JOBDIR='${jobdir//$q/$Q}'"
      echo "IDTSUB_COMMAND='${command1//$q/$Q}'"
      echo "IDTSUB_REPLACE='${range_rep//$q/$Q}'"
      echo "IDTSUB_PWD='${PWD//$q/$Q}'"
      echo "IDTSUB_HOME='${HOME//$q/$Q}'"
      tail -n +7 "$idtsub_data_path"/template/job.sh |
        sed "s/%%MIN%%/$beg/g;s/%%MAX%%/$((end-1))/g;s/%%COUNT%%/$count/g"
    } > "$fjob"

    local fsub=$jobdir/sub.sh
    {
      local _idtsub_tmpdir=
      [[ $flags == *t* ]] && _idtsub_tmpdir=$idtsub_tmpdir_base/${jobdir##*/}

      echo '#!/usr/bin/env bash'
      echo "IDTSUB_JOBDIR='${jobdir//$q/$Q}'"
      echo "IDTSUB_TMPDIR='${_idtsub_tmpdir//$q/$Q}'"
      tail -n +4 "$idtsub_data_path"/template/sub.sh
    } > "$fsub"

    chmod +x "$fjob" "$fsub"

    local date=$(date +"%F %T %Z")
    local job_range_suffix=
    local cmd_range_suffix=
    local log_range_suffix=
    if [[ $flags == *r* ]]; then
      log_range_suffix=" (range $beg:$end)"
      job_range_suffix="[$beg:$end]"
      cmd_range_suffix=" (${range_rep:+$range_rep=}$beg:$end)"
    fi
    echo "submit: $command$cmd_range_suffix"
    echo "[$date] $submit_hash JOB_ID ${jobdir##*/}$log_range_suffix" >> "$idtsub_data_path"/submit.log
    echo "[$date] IDTSUB submit" >> "$flog"
    {
      echo "command='${command//$q/$Q}$cmd_range_suffix'"
      echo "cwd='${PWD//$q/$Q}'"
      echo "stat=P"
    } >> "$fstat"
    if ! (cd "$jobdir"; sbatch -N 1 -p amd_256 -J "$job_name$job_range_suffix" sub.sh); then
      echo "idtsub:${jobdir##*/}: failed to submit" >&2
      echo "[$(date +"%F %T %Z")] IDTSUB submit fail" >> "$flog"
      echo "stat=F" >> "$fstat"
      return 1
    fi
  done
}

function cmd:stat/list {
  local flags= #C

  echo 'INDE JOB_ID             NODE       STAT   COMMAND'

  local jobdir index=0
  for jobdir in "$idtsub_data_path"/jobs/????????-??????-*; do
    ((index++))
    local job_id=${jobdir##*/}
    local stat=- fail=0 command=- cwd=- node=-
    [[ $flags == *C* && -s $jobdir/complete.mark ]] && continue

    if [[ -s $jobdir/stat.sh ]]; then
      source "$jobdir/stat.sh"
    elif [[ -s $jobdir/complete.mark ]]; then
      stat=C
    fi

    ((fail)) && stat=F$fail
    local sgr_stat=
    case $stat in
    (F*) sgr_stat=$'\e[1;91m' ;;
    (C*) [[ $stat == C ]] && stat=COMP
         sgr_stat=$'\e[94m' ;;
    (R*) sgr_stat=$'\e[1;92m' ;;
    (P*) sgr_stat=$'\e[32m' ;;
    esac

    printf '%04d %-18s %-10.10s %s%-6s%s %s\n' \
           "$index" "$job_id" "$node" \
           "$sgr_stat" "$stat" $'\e[m' \
           "$command"
  done
}

function idtsub/jobdir-eval {
  if [[ ! $1 || ${1//[0-9]} ]]; then
    echo "idtsub: invalid job_index '$1'." >&2
    return 1
  fi

  local index=$((10#$1)) command=$2
  local jobdir i=0
  for jobdir in "$idtsub_data_path"/jobs/????????-??????-*; do
    if ((++i==index)); then
      (cd "$jobdir"; eval -- "$command")
      return
    fi
  done
  echo "idtsub: job_index '$1' not found." >&2
  return 1
}

function cmd:stat {
  if (($#==0)); then
    cmd:stat/list
    return "$?"
  fi

  case $2 in
  (''|log)
    idtsub/jobdir-eval "$1" 'cat stat.log' ;;
  (out|tail)
    local -a tail_options=()
    tail_options=()
    [[ $2 == out ]] && tail_options+=(-n +1)
    idtsub/jobdir-eval "$1" '
      [[ -s complete.mark ]] || tail_options+=(-f)
      tail "${tail_options[@]}" sub.out' ;;
  (stat.sh|sub.sh|job.sh|cmd.sh)
    idtsub/jobdir-eval "$1" 'cat '"$2" ;;
  (ls)
    idtsub/jobdir-eval "$1" 'ls -la' ;;
  (*)
    echo "idtsub/stat: unknown stat type '$2'" >&2
    return 2 ;;
  esac
}

function main {
  if (($#==0)); then
    cmd:stat
    return
  elif is-function "cmd:$1"; then
    "cmd:$@"
    return
  elif local rex='^s[0-9]+$'; [[ $1 =~ $rex ]]; then
    cmd:stat "${1:1}" "${@:2}"
    return
  fi

  # case $1 in
  # (*)
  # esac

  echo "idtsub: unknown subcommand '$1'" >&2
  exit 2
}

main "$@"
